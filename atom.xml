<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hhdds&#39;s blog</title>
  
  <subtitle>学习，分享，记录。</subtitle>
  <link href="https://hhdds1377.github.io/atom.xml" rel="self"/>
  
  <link href="https://hhdds1377.github.io/"/>
  <updated>2025-11-27T13:04:31.376Z</updated>
  <id>https://hhdds1377.github.io/</id>
  
  <author>
    <name>hhdds</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础部分</title>
    <link href="https://hhdds1377.github.io/2025/06/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>https://hhdds1377.github.io/2025/06/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</id>
    <published>2025-06-15T07:23:25.000Z</published>
    <updated>2025-11-27T13:04:31.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-控制流工具"><a href="#1-控制流工具" class="headerlink" title="1 控制流工具"></a>1 控制流工具</h1><p>什么是<strong>控制流工具</strong>?</p><p>在Python中,语法可以不规范地分为关键字语法和非关键字语法.</p><p>除去作为值和变量,操作符的关键字(None,True,False,is,not,or,and,in),关键字语法的结构往往是<strong>表达式结构</strong>,而非关键字语法往往是<strong>面向对象</strong>的,控制流工具离不开关键字.</p><p>所以,控制流工具就是由部分关键字引导的表达式结构.</p><h2 id="1-1-条件控制-if-语句"><a href="#1-1-条件控制-if-语句" class="headerlink" title="1.1 条件控制 - if 语句"></a>1.1 条件控制 - if 语句</h2><p>在条件控制中,包含以下关键字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">elif</span> <span class="keyword">else</span></span><br></pre></td></tr></table></figure><p>if 语句必须含有if部分,elif和else部分是可选的,按照结构可以笼统分为:</p><p>并列条件:if…elif…else….</p><p>嵌套条件:并列条件的嵌套使用.</p><h2 id="1-2-循环控制-for-语句和-while-语句"><a href="#1-2-循环控制-for-语句和-while-语句" class="headerlink" title="1.2 循环控制 - for 语句和 while 语句"></a>1.2 循环控制 - for 语句和 while 语句</h2><p>在循环控制中,包含以下关键字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> <span class="keyword">while</span> <span class="keyword">continue</span> <span class="keyword">break</span> <span class="keyword">else</span></span><br></pre></td></tr></table></figure><h3 id="1-2-1-for-语句"><a href="#1-2-1-for-语句" class="headerlink" title="1.2.1 for 语句"></a>1.2.1 for 语句</h3><p>for 语句的作用是在序列(也可以是迭代器)上迭代.它的语法是:</p><p><code>for var in seq:</code></p><p>与for 语句配合的常用函数有range(start,end,step),enumerate(seq).</p><h3 id="1-2-2-while-语句"><a href="#1-2-2-while-语句" class="headerlink" title="1.2.2 while 语句"></a>1.2.2 while 语句</h3><p>while 语句的作用是在语句中循环,直到条件不再满足.它的语法是:</p><p><code>while LogicException:</code></p><h3 id="1-2-3-continue和break"><a href="#1-2-3-continue和break" class="headerlink" title="1.2.3 continue和break"></a>1.2.3 continue和break</h3><p>continue的作用是跳出此次循环,进入下一个循环,如果是最后一次循环,结束循环.</p><p>break的作用是跳出所有循环,结束循环.</p><h3 id="1-2-3-else"><a href="#1-2-3-else" class="headerlink" title="1.2.3 else"></a>1.2.3 else</h3><p>else的作用与条件控制有些不一样,只有循环不被break关键字中断时,循环结束后会执行else字段.</p><h2 id="1-3-异常控制-try-语句"><a href="#1-3-异常控制-try-语句" class="headerlink" title="1.3 异常控制 - try 语句"></a>1.3 异常控制 - try 语句</h2><p>在异常控制中,包含以下关键字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> <span class="keyword">except</span> <span class="keyword">else</span> <span class="keyword">finally</span> <span class="keyword">raise</span> <span class="keyword">from</span> <span class="keyword">assert</span></span><br></pre></td></tr></table></figure><h3 id="1-3-1-try-语句"><a href="#1-3-1-try-语句" class="headerlink" title="1.3.1 try 语句"></a>1.3.1 try 语句</h3><p>在try语句中,try必须有配套的except,else和finally是可选的.</p><p>结构通常为:<code>try...except...else...finally</code></p><h3 id="1-3-2-raise-抛出异常"><a href="#1-3-2-raise-抛出异常" class="headerlink" title="1.3.2 raise 抛出异常"></a>1.3.2 raise 抛出异常</h3><p>raise语段的语法为<code>raise ErrorClass(ErrorException) from ParentError</code></p><p>作用:指定错误类型,可选地加入错误描述和父错误(用于形成错误链).</p><p>解析:</p><ol><li>ErrorClass:抛出的错误的类型.</li><li>ErrorException:错误描述.</li><li>parentError:如果parentError被抛出,会导致该错误也被抛出.这种连环错误被称为错误链.</li></ol><h3 id="1-3-3-assert-断言"><a href="#1-3-3-assert-断言" class="headerlink" title="1.3.3 assert 断言"></a>1.3.3 assert 断言</h3><p>assert的语法为<code>assert LogicException[,ErrorException]</code></p><p>作用:检测逻辑体,如果为是,略过,如果为否,抛出AssertionError,可以指定错误描述.</p><p>解析:</p><ol><li>LogicException:逻辑体,必须返回布尔值.</li><li>ErrorException:错误描述.</li></ol><h3 id="1-3-4-引发和处理多个不相关的异常"><a href="#1-3-4-引发和处理多个不相关的异常" class="headerlink" title="1.3.4 引发和处理多个不相关的异常"></a>1.3.4 引发和处理多个不相关的异常</h3><p>内置的ExceptionGroup,语法为:</p><p><code>ExceptionGroup(ErrorException,Errorlist)</code></p><p>它打包了一个异常实例的列表,可以一起被引发,它本身就是一个异常,可以被捕获.</p><p><strong>except*</strong></p><p>通过使用except*代替except,可以选择地处理组中复合某种类型的异常.</p><h3 id="1-3-5-add-note-note-注释化异常"><a href="#1-3-5-add-note-note-注释化异常" class="headerlink" title="1.3.5 add_note(note)注释化异常"></a>1.3.5 add_note(note)注释化异常</h3><p>error.add_note(note)</p><p>作用:注释化异常,接收一个字符串,并将其添加到异常的注释列表.</p><p>解析:</p><ol><li>note:被添加的注释.</li></ol><h2 id="1-4-函数控制-def-语句和-lambda-语句"><a href="#1-4-函数控制-def-语句和-lambda-语句" class="headerlink" title="1.4 函数控制 - def 语句和 lambda 语句"></a>1.4 函数控制 - def 语句和 lambda 语句</h2><h3 id="1-4-1-def-和-lambda-语法"><a href="#1-4-1-def-和-lambda-语法" class="headerlink" title="1.4.1 def 和 lambda 语法"></a>1.4.1 def 和 lambda 语法</h3><p>函数控制的关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lambda</span></span><br></pre></td></tr></table></figure><p>作用：</p><ol><li><p>def</p><p>后跟函数名与括号内的形参列表.</p></li><li><p>lambda</p><p><code>lambda [char1, char2 , ...] : expression</code></p></li></ol><h3 id="1-4-2-文档字符串"><a href="#1-4-2-文档字符串" class="headerlink" title="1.4.2 文档字符串"></a>1.4.2 文档字符串</h3><p>文档字符串: 函数内的第一条语句(可以跨行,但必须用跨行字符串)是字符串时, 该字符串就是文档字符串(docstring).</p><p>文档字符串的作用:</p><ol><li><p>利用自动化工具(如Sphinx等)自动生成在线文档或打印版文档.</p></li><li><p>帮助开发者在浏览代码时直接查阅文档,利用__doc__属性或help(defname)内置函数可以查看该字符串.</p></li></ol><p>多行文档字符串的书写规范(PEP 257):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def &lt;fnc&gt;(chars):</span><br><span class="line">    &lt;作用描述&gt;</span><br><span class="line"></span><br><span class="line">    &lt;参数(arguments)&gt; &quot;:&quot;</span><br><span class="line">        &lt;参数1&gt; &quot;(&quot; (&lt;参数类型&gt; &quot;/&quot;?) * &quot;)&quot; &quot;:&quot; &lt;参数描述&gt;</span><br><span class="line">        (&lt;参数2&gt; &quot;(&quot; (&lt;参数类型&gt; &quot;/&quot;?) * &quot;)&quot; &quot;:&quot; &lt;参数描述&gt;)*</span><br><span class="line"></span><br><span class="line">    &lt;返回(return)&gt; &quot;:&quot;</span><br><span class="line">        &lt;返回值类型&gt; &quot;:&quot; &lt;返回值解析&gt;</span><br></pre></td></tr></table></figure><p>文档字符串与普通注释的区别:</p><p>会被Python解释器解释,而普通注释会被忽视.</p><h3 id="1-4-3-局部变量符号表"><a href="#1-4-3-局部变量符号表" class="headerlink" title="1.4.3 局部变量符号表"></a>1.4.3 局部变量符号表</h3><p>引用变量时,首先,在局部符号表里查找变量,然后,是外层函数局部符号表,再是全局符号表,最后是内置名称符号表.</p><h3 id="1-4-4-位置参数"><a href="#1-4-4-位置参数" class="headerlink" title="1.4.4 位置参数"></a>1.4.4 位置参数</h3><p>与形参一一对应的参数是位置参数.</p><h3 id="1-4-5-关键字参数"><a href="#1-4-5-关键字参数" class="headerlink" title="1.4.5 关键字参数"></a>1.4.5 关键字参数</h3><p>形似kwarg&#x3D;value形式的参数是关键字参数.</p><h3 id="1-4-6-特殊参数"><a href="#1-4-6-特殊参数" class="headerlink" title="1.4.6 特殊参数"></a>1.4.6 特殊参数</h3><p>&#x2F;和*是可选的特殊参数,可以限定参数是位置参数还是关键字参数.</p><p>在&#x2F;前的参数是位置参数,在&#x2F;和*中的参数可以是两种参数,在*后的参数是关键字参数.</p><h3 id="1-4-7-任意实参列表"><a href="#1-4-7-任意实参列表" class="headerlink" title="1.4.7 任意实参列表"></a>1.4.7 任意实参列表</h3><p>*args表示可变数量的位置参数.</p><p>**kwargs表示可变数量的关键字参数.</p><h3 id="1-4-8-解包实参列表"><a href="#1-4-8-解包实参列表" class="headerlink" title="1.4.8 解包实参列表"></a>1.4.8 解包实参列表</h3><p>*符号可以将元祖或列表中的参数解包出来.</p><p>**符号可以将字典中的参数解包出来.</p><h2 id="1-5-匹配控制-match-语句"><a href="#1-5-匹配控制-match-语句" class="headerlink" title="1.5 匹配控制 - match 语句"></a>1.5 匹配控制 - match 语句</h2><p>匹配控制的关键字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">case</span> <span class="keyword">as</span></span><br></pre></td></tr></table></figure><p>match语句接收一个表达式并把它的值与一个或多个case块给出的一系列模式进行比较.只有第一个匹配的模式会被执行.</p><p>match语句也可以用于捕获值.</p><p>结构是:match…case,match和case都是必要的.</p><p>需要注意的是,_在match语句中可以作为通配符,位置在match语句的最后一个case子语句,表示如果没有其他case被匹配成功,则_被匹配成功.</p><p>也可以用|将多个值组合到一个模式中.</p><h2 id="1-6-pass-语句"><a href="#1-6-pass-语句" class="headerlink" title="1.6 pass 语句"></a>1.6 pass 语句</h2><p>pass语句不执行任何动作.语法上需要一个语句,但程序不需执行任何动作时,可以使用该语句.</p><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><h2 id="2-1-列表"><a href="#2-1-列表" class="headerlink" title="2.1 列表"></a>2.1 列表</h2><h3 id="2-1-1-列表的方法"><a href="#2-1-1-列表的方法" class="headerlink" title="2.1.1 列表的方法"></a>2.1.1 列表的方法</h3><ol><li><p>list.append(x)</p><p>在列表末尾添加一项,类似于a[len(a):]&#x3D;[x].</p></li><li><p>list.extend(iterable)</p><p>通过添加来自iterable的所有项来扩展列表.类似于a[len(a):]&#x3D;iterable</p></li><li><p>list.insert(i,x)</p><p>在指定位置插入元素.第一个参数是插入元素的索引,因此,a.insert(0,x)在列表开头插入元素,a.insert(len(a),x)等同于a.append(x).</p></li><li><p>list.remove(x)</p><p>从列表中删除第一个值为x的元素.未找到指定元素时,触发ValueError异常.</p></li><li><p>list.pop([i])</p><p>移除列表中给定位置上的条目,并返回该条目.如果未指定索引号,则a.pop()将移除并返回列表中的最后一个条目.如果列表为空或索引号在列表索引范围之外则会引发IndexError.</p></li><li><p>list.clear()</p><p>移除列表中的所有项.类似于del a[:]</p></li><li><p>list.index(x[,start[,end]])</p><p>返回列表中第一个值为x的元素的零基索引.未找到指定元素时,触发,ValueError异常.</p><p>可选参数start和end是切片符号,用于将搜索限制为列表的特定子序列.</p></li><li><p>list.count(x)</p><p>返回列表中元素x出现的次数.</p></li><li><p>list.sort(*,key&#x3D;None,reverse&#x3D;False)</p><p>就地排序列表中的元素.</p><p>参数:</p><ol><li>key:一般是函数,如果带参数,需要与lambda联用.例如:key&#x3D;lambda i:len(i)或key&#x3D;lambda i:i[account]等等.</li></ol></li><li><p>list.reverse()</p><p>翻转列表中的元素.</p></li><li><p>list.copy()</p><p>返回列表的浅拷贝.类似于a[:].</p></li></ol><h3 id="2-1-2-用列表实现堆栈"><a href="#2-1-2-用列表实现堆栈" class="headerlink" title="2.1.2 用列表实现堆栈"></a>2.1.2 用列表实现堆栈</h3><p>堆栈就是”先进后出”的线性表.添加条目到栈顶,可使用append(),从栈顶取出条目,则使用pop().</p><h3 id="2-1-3-用列表实现队列"><a href="#2-1-3-用列表实现队列" class="headerlink" title="2.1.3  用列表实现队列"></a>2.1.3  用列表实现队列</h3><p>队列就是”先进先出”的线性表.</p><p>但是列表作为队列的效率很慢,因为在列表插入或移除元素很慢,所有元素都必须移动一位.</p><p>实现队列最好用collections.deque库,可以快速从两端添加或删除元素.</p><p><strong>collections.deque模块的常用方法</strong></p><ol><li><p>appendleft(x)</p><p>在队列左端添加元素.</p></li><li><p>popleft(x)</p><p>在队列左端删除元素.</p></li><li><p>extendleft(iterable)</p><p>在队列左端添加可迭代对象的所有项.</p></li></ol><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue=deque([<span class="string">&quot;Eric&quot;</span>,<span class="string">&quot;john&quot;</span>,<span class="string">&quot;Michael&quot;</span>])</span><br><span class="line">queue.append(<span class="string">&quot;Terry&quot;</span>)</span><br><span class="line">queue.append(<span class="string">&quot;Graham&quot;</span>)</span><br><span class="line">queue.popleft()</span><br><span class="line">queue.popleft()</span><br></pre></td></tr></table></figure><h3 id="2-1-4-列表推导式"><a href="#2-1-4-列表推导式" class="headerlink" title="2.1.4 列表推导式"></a>2.1.4 列表推导式</h3><p>列表推导式的语法:</p><p><code>[expression for statement (for statement)* (if statement)*]</code></p><p>即一个表达式,后面为一个for子句,然后,是零个或多个for或if子句.</p><h3 id="2-1-5-del语句"><a href="#2-1-5-del语句" class="headerlink" title="2.1.5 del语句"></a>2.1.5 del语句</h3><p>可以按索引从一个列表移除条目.</p><h2 id="2-2-元祖"><a href="#2-2-元祖" class="headerlink" title="2.2 元祖"></a>2.2 元祖</h2><h3 id="2-2-1-单元素元祖"><a href="#2-2-1-单元素元祖" class="headerlink" title="2.2.1 单元素元祖"></a>2.2.1 单元素元祖</h3><p>必须在元素后面接逗号.如<code>(&#39;a&#39;,)</code>,<code>&#39;hello&#39;,</code></p><h3 id="2-2-2-打包和解包"><a href="#2-2-2-打包和解包" class="headerlink" title="2.2.2 打包和解包"></a>2.2.2 打包和解包</h3><p>t&#x3D;12345,54321,’hello’</p><p>这是打包</p><p>x,y,z&#x3D;t</p><p>这是解包</p><h3 id="2-2-3-元组的函数和方法"><a href="#2-2-3-元组的函数和方法" class="headerlink" title="2.2.3 元组的函数和方法"></a>2.2.3 元组的函数和方法</h3><p><strong>工厂函数</strong></p><ol><li><p>tuple(obj)</p><p> 作用:将对象转换成元组.</p></li></ol><p><strong>其他函数和方法</strong></p><p>与列表基本相同,但元组是不可变序列类型,所以没有添加,删除等等修改方法.</p><h2 id="2-3-集合"><a href="#2-3-集合" class="headerlink" title="2.3 集合"></a>2.3 集合</h2><h3 id="2-3-1-集合的创建"><a href="#2-3-1-集合的创建" class="headerlink" title="2.3.1 集合的创建"></a>2.3.1 集合的创建</h3><p>创建集合用花括号或set()函数,创建空集合只能用set(),以免和字典冲突.</p><h3 id="2-3-2-集合运算符"><a href="#2-3-2-集合运算符" class="headerlink" title="2.3.2 集合运算符"></a>2.3.2 集合运算符</h3><ol><li><ul><li></li></ul><p>作用:差集</p></li><li><p>|</p><p>作用:并集</p></li><li><p>&amp;</p><p>作用:交集</p></li><li><p>^</p><p>作用:存在于a或b中但非两者中皆有的元素.</p></li></ol><h3 id="2-3-3-集合的函数和方法"><a href="#2-3-3-集合的函数和方法" class="headerlink" title="2.3.3 集合的函数和方法"></a>2.3.3 集合的函数和方法</h3><p><strong>创建集合</strong></p><ol><li><p>dict(seq)</p><p> 作用:将序列对象转换成字典.例如:<code>[(key1,value1),(key2,value2),(key3,value3)]</code>,<code>zip([key1,key2,key3],[value1,value2,value3])</code>.</p></li><li><p>dict.fromkeys(seq[,value])</p><p> 作用:内置类dict的方法,将序列seq作用键值,同时它们的值都是value.</p></li></ol><p><strong>修改字典</strong></p><ol><li><p>clear()</p><p> 作用:清除字典中的左右元素.</p></li><li><p>pop(key[,default])</p><p> 作用:通过键key删除键-值对,并返回元组(键,值).如果没有找到键,返回默认值default.</p></li><li><p>popitem()</p><p> 作用:随机删除一个键-值对,并返回元组(键,值).</p></li><li><p>update(dict)</p><p> 作用:将新字典的键-值一次性添加到当前字典中,如果两个字典中由相同的键,则以新字典的值为标准更新当前字典.</p></li><li><p>copy()</p><p> 作用:浅复制字典.</p></li><li><p>items()</p><p> 作用:以列表形式返回一个可遍历的键-值元组.</p></li><li><p>keys()</p><p> 作用:以列表形式返回可遍历的字典中的所有的键.</p></li><li><p>values()</p><p> 作用:以列表形式返回可遍历的字典中的所有值.</p></li><li><p>get(key[,default&#x3D;None])</p><p> 作用:与dict[key]相同.如果没有指定的键,则返回默认值.</p></li></ol><h2 id="2-4-字典"><a href="#2-4-字典" class="headerlink" title="2.4 字典"></a>2.4 字典</h2><h3 id="2-4-1-字典推导式"><a href="#2-4-1-字典推导式" class="headerlink" title="2.4.1 字典推导式"></a>2.4.1 字典推导式</h3><p>语法:</p><p><code>expression for statement (for statement)* (if statement)*</code></p><h2 id="2-5-深入条件控制"><a href="#2-5-深入条件控制" class="headerlink" title="2.5 深入条件控制"></a>2.5 深入条件控制</h2><ol><li>比较运算符:in not is is not &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D;</li><li>布尔运算符:not and or</li></ol><p>比较运算符的优先级大于布尔运算符,比较运算符的优先级一样,布尔运算符的优先级not &gt; and &gt;or.</p><h1 id="3-模块"><a href="#3-模块" class="headerlink" title="3 模块"></a>3 模块</h1><h2 id="3-1-模块详解"><a href="#3-1-模块详解" class="headerlink" title="3.1 模块详解"></a>3.1 模块详解</h2><h3 id="3-1-1-以脚本模式运行Python模块"><a href="#3-1-1-以脚本模式运行Python模块" class="headerlink" title="3.1.1 以脚本模式运行Python模块"></a>3.1.1 以脚本模式运行Python模块</h3><p>语法:</p><p><code>python fibo.py &lt;arguments&gt;</code></p><p>参数:</p><p>arguments:命令行参数,在运行脚本时传递给Python程序使用.在Python脚本中,命令行参数一般通过sys.argv访问.sys.argv[0]代表脚本名,sys.argv[1]代表第一个命令行参数,以此类推.</p><h3 id="3-1-2-模块搜索路径"><a href="#3-1-2-模块搜索路径" class="headerlink" title="3.1.2 模块搜索路径"></a>3.1.2 模块搜索路径</h3><p>当导入一个模块时,搜索优先级为:</p><ol><li>内置模块,在sys.builtin_module_names中列出</li><li>sys.path所给出的目录列表</li></ol><p>sys.path包含以下位置:</p><ol><li>被命令行直接运行的脚本所在的目录(或指定的当前目录)</li><li>PYTHONPATH(目录列表,与shell变量PATH的语法一样)</li><li>依赖于安装的默认值(按照惯例包括一个site-packages目录,有site模块处理)</li></ol><h3 id="3-1-3-“已编译的”Python文件"><a href="#3-1-3-“已编译的”Python文件" class="headerlink" title="3.1.3 “已编译的”Python文件"></a>3.1.3 “已编译的”Python文件</h3><p><code>__pycache__</code>是Python模块的编译版本目录目录,在这个目录中,文件名为<code>module.version.pyc</code>,module是模块名,version是Python版本号(但与一般的版本号有区别),pyc是固定后缀,例如:在CPython3.3发行版中,spam.py模块的编译版本缓存为<code>__pycache__/spam.cpython-33.pyc</code>.</p><h2 id="3-2-标准模块"><a href="#3-2-标准模块" class="headerlink" title="3.2 标准模块"></a>3.2 标准模块</h2><p>Python自带一个标准模块的库.</p><p>特别的模块sys,内嵌的标准模块,sys.ps1,sys.ps2定义了一些字符,用作主提示符和辅助提示符.sys.path是字符串列表,用于确定解释器的模块搜索路径.该路径以环境变量PYTHONPATH提取的默认路径进行初始化,如未设置PYTHONPATH,则使用内置的默认路径.</p><p>甚至可以使用列表操作修改该列表:</p><p><code>sys.path.append(path)</code></p><h2 id="3-3-dir-函数"><a href="#3-3-dir-函数" class="headerlink" title="3.3 dir()函数"></a>3.3 dir()函数</h2><p>内置函数dir()用于查找模块定义的名称.返回结果是经过排序的字符串列表.</p><p>语法:</p><p><code>dir(module)</code></p><p>作用:返回模块定义的名称.没有参数时,返回当前已定义的名称.</p><p>定义的名称包括:变量,模块,函数,…</p><p>dir()不会列出内置函数及其变量的名称,这些内容的定义在标准模块builtins中.</p><h2 id="3-4-包"><a href="#3-4-包" class="headerlink" title="3.4 包"></a>3.4 包</h2><p>包是通过使用”带点号模块名”来构造Python模块命名空间的一种方式.</p><p>一般地,需要有<code>__init__.py</code>文件才能让Python将包含该文件的目录当作包来处理(除非使用namespace package).在最简单的情况下,<code>__init__</code>可以只是一个空文件,但它也可以执行包的初始化代码或设置<code>__all__</code>变量.</p><h2 id="3-5-从包中导入"><a href="#3-5-从包中导入" class="headerlink" title="3.5 从包中导入*"></a>3.5 从包中导入*</h2><p>不建议使用from package import *时,因为会花费很长的时间,除非作者在<code>__init__.py</code>代码中定义了列表<code>__all__</code>.如果存在<code>__all__</code>列表,运行from package import *时,它就是被导入的模块名列表.发布包的新版本时,包的作者应更新此列表.</p><h1 id="4-变量和标识符"><a href="#4-变量和标识符" class="headerlink" title="4 变量和标识符"></a>4 变量和标识符</h1><h2 id="4-1-变量"><a href="#4-1-变量" class="headerlink" title="4.1 变量"></a>4.1 变量</h2><p>Python中的变量使用标识符标识,无需声明类型即可创建</p><h2 id="4-2-标识符"><a href="#4-2-标识符" class="headerlink" title="4.2 标识符"></a>4.2 标识符</h2><p>Python中的标识符遵循以下规则:</p><ol><li>使用字母,数字和下划线”_”组成</li><li>数字不能再标识符的开头</li><li>区分大小写</li></ol><h1 id="5-输入与输出"><a href="#5-输入与输出" class="headerlink" title="5 输入与输出"></a>5 输入与输出</h1><h2 id="5-1-更复杂的输出格式"><a href="#5-1-更复杂的输出格式" class="headerlink" title="5.1 更复杂的输出格式"></a>5.1 更复杂的输出格式</h2><p>格式化输出的方法:</p><ol><li>格式化字符串字面值,俗称f-格式化.要在字符串开头的引号&#x2F;三引号前添加f或F.</li><li>字符串的str.format()方法</li></ol><h3 id="5-1-1-格式化字符串字面值"><a href="#5-1-1-格式化字符串字面值" class="headerlink" title="5.1.1 格式化字符串字面值"></a>5.1.1 格式化字符串字面值</h3><p>语法:</p><p>{expression}</p><p>其中,格式说明符是可选的.</p><p>常用的格式说明符:</p><ol><li>.nf:表示精确到n为小数</li><li>冒号接的整数,表示设置最小字符宽度.</li><li>在冒号之前,一些修饰符可以在格式化前转换值,’!a’应用ascii(),’!s’应用str(),’!r’应用repr().</li><li>&#x3D;说明符(在冒号之前)用于显示变量,即”变量&#x3D;值”.</li></ol><h3 id="5-1-2-字符串format-方法"><a href="#5-1-2-字符串format-方法" class="headerlink" title="5.1.2 字符串format()方法"></a>5.1.2 字符串format()方法</h3><p>str.fromat()方法的基本用法:</p><p><code>&quot;&#123;expression&#125;&quot;.format(args)</code></p><ol><li><p>无参数</p><p>花括号中没有任何参数,实际上隐藏了位置参数.</p></li><li><p>位置参数</p><p>花括号中的数字表示传递给str.format()方法的对象所在的位置.</p></li><li><p>关键字参数</p><p>花括号中的参数与str.format()方法中的关键字参数对应,类似于函数中的关键字参数.</p></li></ol><h3 id="5-1-3-手动格式化字符串"><a href="#5-1-3-手动格式化字符串" class="headerlink" title="5.1.3 手动格式化字符串"></a>5.1.3 手动格式化字符串</h3><ol><li><p>str.rjust(num)</p><p>作用:在左侧填充空格,num是给定宽度.</p></li><li><p>str.ljust(num)</p><p>作用:在右侧填充空格,num是给定宽度.</p></li><li><p>str.center(num)</p><p>作用:在两侧填充空格,num是给定宽度.</p></li><li><p>str.zfill()</p><p>作用:在数字字符串左边填充零,且能识别正负号.</p></li></ol><h2 id="5-2-读写文件"><a href="#5-2-读写文件" class="headerlink" title="5.2 读写文件"></a>5.2 读写文件</h2><h3 id="5-2-1-文件对象的方法"><a href="#5-2-1-文件对象的方法" class="headerlink" title="5.2.1 文件对象的方法"></a>5.2.1 文件对象的方法</h3><ol><li><p>f.read(size)</p><p>作用:读取文件内容.</p><p>参数:</p><ol><li>size:读取最多size个字符(文本模式)或size个字节(二进制模式).</li></ol></li><li><p>f.readline()</p><p>作用:从文件中读取单行数据.字符串末尾保留换行符.</p></li><li><p>for line in f:</p><p>作用:遍历整个文件对象,即从文件中读取多行.</p></li><li><p>list(f)</p><p>作用:将文件对象转换成列表,内容与f.readlines()相同.</p></li><li><p>f.readlines()</p><p>作用:读取文件中的所有行.</p></li><li><p>f.write(string)</p><p>作用:把string的内容写入文件,并返回写入的字符数.</p></li><li><p>f.tell()</p><p>作用:返回整数,给出文件对象在文件中的对钱位置,表示为二进制模式下时从文件开始的字节数和文本模式下的意义不明的数字.</p></li><li><p>f.seek(offset,whence)</p><p>作用:可以改变文件对象的位置.</p><p>参数:</p><ol><li>offset:偏移量.</li><li>whence:指定参考点,0表示开头,1你是当前文件位置,2表示文件默认,默认0.</li></ol><p>注意:</p><ol><li>在文本模式中,只允许从文件开头搜索.</li><li>有效的offset值必须属于f.tell()的返回值或0.</li></ol></li></ol><h3 id="5-2-2-读写CSV文件"><a href="#5-2-2-读写CSV文件" class="headerlink" title="5.2.2 读写CSV文件"></a>5.2.2 读写CSV文件</h3><p>Python使用标准库csv读写csv文件.</p><ol><li><p>csv.reader(csv_fileobj,dialect)</p><p>作用:选取某种dialect确定csv编码风格,从csv_fileobj(csv文本文件对象)中读取内容.</p><p>参数和它的值:</p><ol><li><p>dialect:编码风格</p><ol><li>‘excel’:默认值,以逗号分隔.</li></ol></li></ol></li><li><p>csv_writer&#x3D;csv.writer(csv_fileobj,dialect)</p><p>作用:选取某种dialect确定csv编码风格,从csv_fileobj(csv文本文件对象)生成csv_writer对象,用于写入数据.</p></li><li><p>csv_writer.writerow(list)</p><p>作用:将一维列表写入到csv_writer对象.</p></li><li><p>csv_writer.writerows(seq)</p><p>作用:将二维序列写入到csv_writer对象.</p></li></ol><h3 id="5-2-3-使用json保存结构化数据"><a href="#5-2-3-使用json保存结构化数据" class="headerlink" title="5.2.3 使用json保存结构化数据"></a>5.2.3 使用json保存结构化数据</h3><p>Python允许使用流行的数据交换格式JSON(JavaScript Object Notation).标准库模块json可以接受带有层级结构的Python数据,并将其转换为字符串表示形式,这个过程称为序列化(serializing),根据字符串表示形式重建数据则称为反序列化(deserializing).</p><ol><li><p>json.dumps(obj: dict | list)</p><p>作用:将字典对象或列表对象转换成JSON对象,即序列化.</p></li><li><p>json.dump(obj: dict | list,fileobj)</p><p>作用:将字典对象或列表对象序列化为JSON对象,并存储在fileobj文件对象中.</p></li><li><p>json.loads(jsonobj)</p><p>作用:将JSON对象转换成Python数据类型(字典或列表),即反序列化.</p></li><li><p>json.load(fileobj)</p><p>作用:将打开的文本文件对象反序列化为Python数据类型(字典或列表).</p></li></ol><h1 id="6-类"><a href="#6-类" class="headerlink" title="6 类"></a>6 类</h1><h2 id="6-1-名称和对象"><a href="#6-1-名称和对象" class="headerlink" title="6.1 名称和对象"></a>6.1 名称和对象</h2><p>Python类也是对象,对象之间相互对立.</p><p>多个名称可以绑定到同一对象,被称为”别名”.</p><h2 id="6-2-Python作用域和命名空间"><a href="#6-2-Python作用域和命名空间" class="headerlink" title="6.2 Python作用域和命名空间"></a>6.2 Python作用域和命名空间</h2><p>命名空间(namespace)是从名称到对象的映射.</p><p>点号之后的名称是<strong>属性</strong>.</p><p>属性可以是只读的或者可写的.</p><p>一个命名空间的<strong>作用域</strong>是Python代码中的一段文本区域,从这个区域可直接访问该命名空间.</p><h2 id="6-2-1-global和nonlocal"><a href="#6-2-1-global和nonlocal" class="headerlink" title="6.2.1 global和nonlocal"></a>6.2.1 global和nonlocal</h2><p>这两个关键字都是改变名称的作用域:</p><ol><li>global:声明特定变量在全局作用域中,在全局作用域中重新绑定.</li><li>nonlocal:声明特定变量在外层作用域中,在外层作用域中重新绑定.</li></ol><h2 id="6-3-初探类"><a href="#6-3-初探类" class="headerlink" title="6.3 初探类"></a>6.3 初探类</h2><p>类引入了一个新语法,三种新的对象类型和一些新语义.</p><h3 id="6-3-1-类定义语法"><a href="#6-3-1-类定义语法" class="headerlink" title="6.3.1 类定义语法"></a>6.3.1 类定义语法</h3><p>语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    &lt;语句-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;语句-N&gt;</span><br></pre></td></tr></table></figure><h3 id="6-3-2-Class对象"><a href="#6-3-2-Class对象" class="headerlink" title="6.3.2 Class对象"></a>6.3.2 Class对象</h3><p>每个值都是一个对像,因此具有类,类的名称存储在<code>object.__class__</code>.</p><p>类对象支持两种操作:属性引用和实例化.</p><p>当一个类定义了<code>__init__()</code>方法时,类的实例化会自动为新创建的类实例发起调用<code>__init__()</code>.并且在类实例化的过程中的参数,传递给了类中的<code>__init__()</code>方法.</p><h3 id="6-3-3-实例对象"><a href="#6-3-3-实例对象" class="headerlink" title="6.3.3 实例对象"></a>6.3.3 实例对象</h3><p>实例对象的唯一操作是属性引用.有两种有效的属性名称:数据属性和方法.</p><h3 id="6-3-4-方法对象"><a href="#6-3-4-方法对象" class="headerlink" title="6.3.4 方法对象"></a>6.3.4 方法对象</h3><p>方法的特殊之处:</p><p>实例对象会作为函数的第一个参数被传入.</p><h3 id="6-3-5-类和实例变量"><a href="#6-3-5-类和实例变量" class="headerlink" title="6.3.5 类和实例变量"></a>6.3.5 类和实例变量</h3><p>一般地,实例变量使用每个实例的唯一数据,而类变量用于类的所有实例共享的属性和方法.</p><h2 id="6-4-继承"><a href="#6-4-继承" class="headerlink" title="6.4 继承"></a>6.4 继承</h2><p>语法:</p><p>class DerivedClassName(BaseClassName)</p><p>注意点:</p><p>派生类的属性引用会先从派生类中查找,再从基类中查找,如果基类也有基类,再从基类的基类中查找,直到递归地找到属性引用.</p><p>两个内置函数用于类的继承:</p><ol><li><p>isinstance(obj,class)</p><p>作用:检查一个实例的类型.仅会在<code>obj.__class__</code>为class类或obj的类派生自class类时为True.</p></li><li><p>issubclass(base,parent)</p><p>作用:检查base是否继承与parent,或base是否是parent的子类.</p></li></ol><h3 id="6-4-1-多重继承"><a href="#6-4-1-多重继承" class="headerlink" title="6.4.1 多重继承"></a>6.4.1 多重继承</h3><p>Python也支持一种多重继承,语法:</p><p>class DerivedClassName(Base1,Base2,Base3):</p><p>属性引用会现在DerivedClassName中查找,就会在Base1中搜索它,然后递归地在Base1的基类中搜索,如果在那里也找不到,在Base2中搜索,依次类推.</p><h2 id="6-5-私有变量"><a href="#6-5-私有变量" class="headerlink" title="6.5 私有变量"></a>6.5 私有变量</h2><p>为何形式为<code>__name</code>的标识符(至少带有两个前缀下划线,至多一个后缀下划线)的文本将被替换为<code>_classname__name</code>,其中classname为去除了前缀下划线的当前类名称.</p><h2 id="6-6-迭代器"><a href="#6-6-迭代器" class="headerlink" title="6.6 迭代器"></a>6.6 迭代器</h2><p>用for语句阐述迭代器:</p><p>for语句会在容器对象上调用iter()(或者是<code>__iter__()</code>方法).该函数返回一个定义了<code>__next__()</code>方法的迭代器对象,此方法将逐一访问容器中的元素.当元素用尽时,<code>__next__()</code>将引发StopIteration异常来通知终止for循环.</p><p>可以使用next()内置函数来调用<code>__next__()</code>方法.</p><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reverse</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data=data</span><br><span class="line">        <span class="variable language_">self</span>.index=<span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.index==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="variable language_">self</span>.index=<span class="variable language_">self</span>.index-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.index]</span><br><span class="line">    </span><br><span class="line">rev=Reverse(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">m</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">p</span></span><br><span class="line"><span class="string">s</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6-7-生成器"><a href="#6-7-生成器" class="headerlink" title="6.7 生成器"></a>6.7 生成器</h2><p>生成器是一个用于创建迭代器的简单而强大的工具.</p><p>生成器会自动创建<code>__iter__()</code>和<code>__next__</code>方法.</p><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">&#x27;golf&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">f</span></span><br><span class="line"><span class="string">l</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6-8-生成器表达式"><a href="#6-8-生成器表达式" class="headerlink" title="6.8 生成器表达式"></a>6.8 生成器表达式</h2><p>与列表表达式类似,但外层是圆括号()而非方括号[].</p><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="6-9-类和对象的内置函数"><a href="#6-9-类和对象的内置函数" class="headerlink" title="6.9 类和对象的内置函数"></a>6.9 类和对象的内置函数</h2><ol><li>hasattr(obj,attr : str)<br> 作用:检查obj是否含有attr这个属性.</li></ol><h1 id="7-虚拟环境和包"><a href="#7-虚拟环境和包" class="headerlink" title="7 虚拟环境和包"></a>7 虚拟环境和包</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>如果有多个Python应用程序,但这些应用程序需要特定版本的第三方库,多个应用程序之间存在它们依赖的第三方库的版本冲突.为了解决这个问题,Python提供创建一个virtual environment,即一个目录树,其中有特定版本的Python,以及许多特定版本的第三方包.</p><h2 id="7-2-创建虚拟环境"><a href="#7-2-创建虚拟环境" class="headerlink" title="7.2 创建虚拟环境"></a>7.2 创建虚拟环境</h2><p>用于创建和管理虚拟环境的模块是venv,虚拟环境的Python副本的版本与当前Python版本一致(即–version选项所报告的版本).</p><p>python -m venv env-path</p><p>作用:创建虚拟环境目录树.</p><p>参数:</p><ol><li>env-path:虚拟目录的位置.</li></ol><p><strong>在创建虚拟环境后,在终端激活虚拟环境:</strong></p><p>在Window上,运行:</p><p>.\env-path\Scripts\activate</p><p>在Unix或MacOS上,运行:</p><p>source env-path&#x2F;bin&#x2F;activate</p><p><strong>要撤销激活一个虚拟环境,在终端输入:</strong></p><p>deactivate</p><p><strong>激活虚拟环境的作用</strong></p><ol><li>激活虚拟环境后,在撤销激活前,如果在当前命令行运行Python文件,Python文件依赖的Python解释器和包均在虚拟环境中.</li><li>在激活虚拟环境中的命令行中,pip命令安装的包的安装位置在虚拟环境中.</li></ol><h2 id="7-3-py切换Python版本"><a href="#7-3-py切换Python版本" class="headerlink" title="7..3 py切换Python版本"></a>7..3 py切换Python版本</h2><p>如果本地安装多个不同版本号的Python,如何切换到不同版本号的Python.</p><ol><li><p>查看所有安装的Python的版本号(无法查看补丁号)</p><p>py -0</p></li><li><p>使当前命令行切换到某个Python版本,取代创建虚拟环境命令中的“python”字段.</p><p>py -3.xx -m venv path</p></li></ol><h2 id="7-4-使用pip管理包"><a href="#7-4-使用pip管理包" class="headerlink" title="7.4 使用pip管理包"></a>7.4 使用pip管理包</h2><ol><li><p>python -m pip install [package[&#x3D;&#x3D;version]]</p><p>作用:使用pip管理包安装第三方库</p><p>参数:</p><ol><li>package[&#x3D;&#x3D;version]:最新版本或特定版本的第三方库名.</li><li>–upgrade [package]:更新pip管理包或软件包.</li><li>-r [path]:读取path指向的文件(内容与python -m pip freeze的输出)中已安装包列表,并安装所有必需的包.</li></ol></li><li><p>python -m pip uninstall [package[&#x3D;&#x3D;version]]</p><p>作用:使用pip管理包卸载第三方库.</p></li><li><p>python -m pip show [package[&#x3D;&#x3D;version]]</p><p>作用:将显示特定包的信息.</p></li><li><p>python -m pip list</p><p>作用:将显示所有安装的包.</p></li><li><p>python -m pip freeze</p><p>作用:将产生一个类似的已安装包列表.</p></li></ol><p><em>有关pip的完整文档请查阅 installing-index 指南, 如果想要编写了一个软件包并希望将其放在 Python Package Index, 请查阅  Python packageing user  guide</em></p><h2 id="7-5-Visual-Studio-Code使用虚拟环境"><a href="#7-5-Visual-Studio-Code使用虚拟环境" class="headerlink" title="7.5 Visual Studio Code使用虚拟环境"></a>7.5 Visual Studio Code使用虚拟环境</h2><p>创建虚拟环境后,进入vs code:</p><p>按下Ctrl+Shift+P,打开命令面板,输入:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Python:</span> <span class="keyword">Select</span> Interpreter</span><br></pre></td></tr></table></figure><p>vs code会列出可用的python解释器,包括虚拟环境中的python解释器,选择虚拟环境的解释器后:</p><p>vs code会自动激活虚拟环境,按下Ctrl+`后,打开vs code的终端,会看到类似输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(.venv) C:\myproject&gt;</span><br></pre></td></tr></table></figure><h1 id="8-浮点数的争议与限制"><a href="#8-浮点数的争议与限制" class="headerlink" title="8 浮点数的争议与限制"></a>8 浮点数的争议与限制</h1><p>为了解决浮点数的精度问题,Python提供以下函数或方法:</p><p>假设这个浮点数是数学中的$\pi$,在Python的math模块中用math.pi表示</p><ol><li><p>format(math.pi,’.xg’)</p><p>保留x个有效数位</p></li><li><p>format(math.pi,’.xf’)</p><p>保留小数点后x个数位</p></li><li><p>round(math.pi,ndigits&#x3D;x)</p><p>精确到小数点后x个数位(有舍入)</p></li><li><p>math.isclose(x,y)</p><p>将x和y进行比较,通常用于解决浮点数精度问题导致的错误比较问题.</p></li><li><p>decimal模块,该模块实现了适合会计应用和高精度应用的十进制运算.</p></li><li><p>fractions模块,该模块实现了基于有理数的算数运算.</p></li><li><p>num.as_integer_ratio()</p><p>将num这个浮点数表示为一个分数.</p></li><li><p>num.hex()</p><p>将num这个浮点数以十六进制表示.</p><p>可以用num16.fromhex()重新精确地转换为浮点数值.</p></li><li><p>sum(equation)</p><p>能够帮助减少求和过程中的精度损失.</p></li><li><p>math.fsum()</p><p>与sum类似,但在一些不常见的情况下更加准确,同时运行速度更慢.</p></li></ol><h1 id="9-标准库简介"><a href="#9-标准库简介" class="headerlink" title="9 标准库简介"></a>9 标准库简介</h1><h2 id="9-1-os"><a href="#9-1-os" class="headerlink" title="9-1 os"></a>9-1 os</h2><ol><li><p>os.path.abspath(rela_path)<br> 作用:获得绝对路径.<br> 参考实参:</p><ol><li><code>__file__</code>:获得当前脚本的绝对路径</li></ol></li><li><p>os.path.diranme(path)<br> 作用:获得目标目录</p></li><li><p>os.path.normpath()<br> 作用:可以用于配合拼接路径.</p></li><li><p>os.path.join(dir,file)<br> 作用:用用拼接路径.</p></li></ol><h2 id="9-2-operator"><a href="#9-2-operator" class="headerlink" title="9-2 operator"></a>9-2 operator</h2><ol><li>operator.itemgetter(*items)<br> 作用:返回一个函数,这个函数作用域可迭代对象或映射对象时,会返回指定的值.</li></ol><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="A-Python-关键字"><a href="#A-Python-关键字" class="headerlink" title="A Python 关键字"></a>A Python 关键字</h2><p>使用<code>print(keyword.kwlist) #import keyword</code>查看Python当前的所有关键字.</p><p><strong>Python所有关键字</strong><br>Python的3.13版本的关键字有36个:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;async&#x27;</span>, <span class="string">&#x27;await&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>Python关键字的分类</strong></p><ol><li><p>值</p><p>None True False</p></li><li><p>异步</p><p>await async</p></li><li><p>操作符</p><p>is in not and or</p></li><li><p>函数</p><p>def lambda return</p></li><li><p>作用域</p><p>global nonlocal</p></li><li><p>条件</p><p>if elif else</p></li><li><p>异常</p><p>try except *else finally assert raise continue from</p></li><li><p>模块</p><p>import as from</p></li><li><p>上下文管理器</p><p>with *as</p></li><li><p>循环</p><p>for *in while continue break *else</p></li><li><p>类</p><p>class</p></li><li><p>方法</p><p>del</p></li><li><p>生成器</p><p>yield</p></li><li><p>占位</p><p>pass</p></li><li><p>匹配</p><p>match case *as</p></li></ol><p>其中,<code>*key</code>表示重复的关键字,关键字最多的分类是<strong>异常</strong>分类,有六个关键字,大部分分类只有1~3个关键字.</p><h2 id="B-Python-解释器内置的帮助文档-Documentation"><a href="#B-Python-解释器内置的帮助文档-Documentation" class="headerlink" title="B Python 解释器内置的帮助文档(Documentation)"></a>B Python 解释器内置的帮助文档(Documentation)</h2><p>在终端使用一下命令在网页打开:</p><p>python -m pydoc -b</p><h2 id="C-去哪里了解-Python"><a href="#C-去哪里了解-Python" class="headerlink" title="C 去哪里了解 Python?"></a>C 去哪里了解 Python?</h2><p><strong>Python 文档集(<a href="https://docs.python.org)中重要文档/">https://docs.python.org)中重要文档</a></strong></p><ol><li><p>toturial-index:</p><p>Python基础.</p></li><li><p>library-index:</p><p>提供了有关标准库中的类型,函数和模块的完整(但简洁)的参考资料.</p></li><li><p>installing-index:</p><p>解释了怎么安装由其他Python开发者编写的模块.</p></li><li><p>reference-index:</p><p>Python的语法和语义的详细解释.</p></li></ol><p><strong>更多Python资源</strong></p><ol><li><a href="https://www.python.org/">https://www.python.org</a>: Python主网站.</li><li><a href="https://docs.python.org:快速访问Python的文档">https://docs.python.org:快速访问Python的文档</a>.</li><li><a href="https://pypi.org/">https://pypi.org</a>: The Python Package Index,是可下载用户自制Python模块的索引.</li><li><a href="https://code.activestate.com/recipes/langs/python/">https://code.activestate.com/recipes/langs/python/</a>: Python Cookbook是一个相当大的代码示例集,更多的模块和有用的脚本.特别值得一看的贡献收集在一本名为Python Cookbook(O’Reilly &amp; Associates,ISBN 0-596-00797-3)的书中.</li><li><a href="https://pyvideo.org:收集了来自研讨会和用户组会议的Python相关视频的链接">https://pyvideo.org:收集了来自研讨会和用户组会议的Python相关视频的链接</a>.</li><li><a href="https://scipy.org:Scientific">https://scipy.org:Scientific</a> Python 项目包含用于快速矩阵计算和操作的模块,以及用于诸如线性代数,傅里叶变换,非线性求解器,随机数分布,统计分析等的一系列包.</li></ol><p><strong>相关的问题和问题报告</strong></p><ol><li>新闻组:comp.lang.python</li><li>邮件列表:<a href="mailto:&#112;&#121;&#x74;&#104;&#x6f;&#110;&#45;&#108;&#105;&#115;&#x74;&#64;&#112;&#121;&#x74;&#104;&#x6f;&#x6e;&#46;&#x6f;&#114;&#x67;">python-list@python.org</a></li><li>邮件列表档案:<a href="https://mail.python.org/pipermail/">https://mail.python.org/pipermail/</a></li></ol>]]></content>
    
    
    <summary type="html">学好Python，必须夯实基础。</summary>
    
    
    
    <category term="Python" scheme="https://hhdds1377.github.io/categories/Python/"/>
    
    
    <category term="技术" scheme="https://hhdds1377.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
