[{"title":"GUI 编程","url":"/2027/07/GUI%20%E7%BC%96%E7%A8%8B/","content":"待续…\n","categories":["Python"],"tags":["技术"]},{"title":"Web 开发","url":"/2027/09/Web%20%E5%BC%80%E5%8F%91/","content":"待续…\n","categories":["Python"],"tags":["技术"]},{"title":"人工智能","url":"/2027/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/","content":"待续…\n","categories":["Python"],"tags":["技术"]},{"title":"游戏开发","url":"/2027/10/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/","content":"待续…\n","categories":["Python"],"tags":["技术"]},{"title":"网络爬虫","url":"/2027/08/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/","content":"待续…\n","categories":["Python"],"tags":["技术"]},{"title":"基础部分","url":"/2025/06/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/","content":"前言本教程主要供已经学习了Python的用户参照学习,不应该用于启蒙.虽然萌新不应该以此作为学习教材,但可以通过本教程观览Python语法的模式和特点.\n在本教程中,有大量的”语法+作用+解析”的讲解方式的嵌套使用,内容趋向”全”,而非”细”.\n另外,本教程采用全英文标点符号,Python版本为”Python 3.13.2”.\n1 控制流工具什么是控制流工具?\n在Python中,语法可以不规范地分为关键字语法和非关键字语法.\n除去作为值和变量,操作符的关键字(None,True,False,is,not,or,and,in),关键字语法的结构往往是表达式结构,而非关键字语法往往是面向对象的,控制流工具离不开关键字.\n所以,控制流工具就是由部分关键字引导的表达式结构.\n1.1 条件控制 - if 语句在条件控制中,包含以下关键字:\nif elif else\n\nif 语句必须含有if部分,elif和else部分是可选的,按照结构可以笼统分为:\n并列条件:if…elif…else….\n嵌套条件:并列条件的嵌套使用.\n1.2 循环控制 - for 语句和 while 语句在循环控制中,包含以下关键字:\nfor in while continue break else\n\n1.2.1 for 语句for 语句的作用是在序列(也可以是迭代器)上迭代.它的语法是:\nfor var in seq:\n与for 语句配合的常用函数有range(start,end,step),enumerate(seq).\n1.2.2 while 语句while 语句的作用是在语句中循环,直到条件不再满足.它的语法是:\nwhile LogicException:\n1.2.3 continue和breakcontinue的作用是跳出此次循环,进入下一个循环,如果是最后一次循环,结束循环.\nbreak的作用是跳出所有循环,结束循环.\n1.2.3 elseelse的作用与条件控制有些不一样,只有循环不被break关键字中断时,循环结束后会执行else字段.\n1.3 异常控制 - try 语句在异常控制中,包含以下关键字:\ntry except else finally raise from assert\n\n1.3.1 try 语句在try语句中,try必须有配套的except,else和finally是可选的.\n结构通常为:try...except...else...finally\n1.3.2 raise 抛出异常raise语段的语法为raise ErrorClass(ErrorException) from ParentError\n作用:指定错误类型,可选地加入错误描述和父错误(用于形成错误链).\n解析:\n\nErrorClass:抛出的错误的类型.\nErrorException:错误描述.\nparentError:如果parentError被抛出,会导致该错误也被抛出.这种连环错误被称为错误链.\n\n1.3.3 assert 断言assert的语法为assert LogicException[,ErrorException]\n作用:检测逻辑体,如果为是,略过,如果为否,抛出AssertionError,可以指定错误描述.\n解析:\n\nLogicException:逻辑体,必须返回布尔值.\nErrorException:错误描述.\n\n1.3.4 引发和处理多个不相关的异常内置的ExceptionGroup,语法为:\nExceptionGroup(ErrorException,Errorlist)\n它打包了一个异常实例的列表,可以一起被引发,它本身就是一个异常,可以被捕获.\nexcept*\n通过使用except*代替except,可以选择地处理组中复合某种类型的异常.\n1.3.5 add_note(note)注释化异常error.add_note(note)\n作用:注释化异常,接收一个字符串,并将其添加到异常的注释列表.\n解析:\n\nnote:被添加的注释.\n\n1.4 函数控制 - def 语句和 lambda 语句1.4.1 def 和 lambda 语法函数控制的关键字：\ndef lambda\n\n作用：\n\ndef\n后跟函数名与括号内的形参列表.\n\nlambda\nlambda [char1, char2 , ...] : expression\n\n\n1.4.2 文档字符串文档字符串: 函数内的第一条语句(可以跨行,但必须用跨行字符串)是字符串时, 该字符串就是文档字符串(docstring).\n文档字符串的作用:\n\n利用自动化工具(如Sphinx等)自动生成在线文档或打印版文档.\n\n帮助开发者在浏览代码时直接查阅文档,利用__doc__属性或help(defname)内置函数可以查看该字符串.\n\n\n多行文档字符串的书写规范(PEP 257):\ndef &lt;fnc&gt;(chars):    &lt;作用描述&gt;    &lt;参数(arguments)&gt; &quot;:&quot;        &lt;参数2&gt; &quot;(&quot; (&lt;参数类型&gt; &quot;/&quot;+) * &quot;)&quot; &quot;:&quot; &lt;参数描述&gt;        (&lt;参数1&gt; &quot;(&quot; (&lt;参数类型&gt; &quot;/&quot;+) * &quot;)&quot; &quot;:&quot; &lt;参数描述&gt;)*    &lt;返回(return)&gt;        &lt;返回值类型&gt; &quot;:&quot; &lt;返回值解析&gt;\n\n文档字符串与普通注释的区别:\n会被Python解释器解释,而普通注释会被忽视.\n1.4.3 局部变量符号表引用变量时,首先,在局部符号表里查找变量,然后,是外层函数局部符号表,再是全局符号表,最后是内置名称符号表.\n1.4.4 位置参数与形参一一对应的参数是位置参数.\n1.4.5 关键字参数形似kwarg&#x3D;value形式的参数是关键字参数.\n1.4.6 特殊参数&#x2F;和*是可选的特殊参数,可以限定参数是位置参数还是关键字参数.\n在&#x2F;前的参数是位置参数,在&#x2F;和*中的参数可以是两种参数,在*后的参数是关键字参数.\n1.4.7 任意实参列表*args表示可变数量的位置参数.\n**kwargs表示可变数量的关键字参数.\n1.4.8 解包实参列表*符号可以将元祖或列表中的参数解包出来.\n**符号可以将字典中的参数解包出来.\n1.5 匹配控制 - match 语句匹配控制的关键字:\nmatch case as\n\nmatch语句接收一个表达式并把它的值与一个或多个case块给出的一系列模式进行比较.只有第一个匹配的模式会被执行.\nmatch语句也可以用于捕获值.\n结构是:match…case,match和case都是必要的.\n需要注意的是,_在match语句中可以作为通配符,位置在match语句的最后一个case子语句,表示如果没有其他case被匹配成功,则_被匹配成功.\n也可以用|将多个值组合到一个模式中.\n1.6 pass 语句pass语句不执行任何动作.语法上需要一个语句,但程序不需执行任何动作时,可以使用该语句.\n2 数据结构2.1 列表2.1.1 列表的方法\nlist.append(x)\n在列表末尾添加一项,类似于a[len(a):]&#x3D;[x].\n\nlist.extend(iterable)\n通过添加来自iterable的所有项来扩展列表.类似于a[len(a):]&#x3D;iterable\n\nlist.insert(i,x)\n在指定位置插入元素.第一个参数是插入元素的索引,因此,a.insert(0,x)在列表开头插入元素,a.insert(len(a),x)等同于a.append(x).\n\nlist.remove(x)\n从列表中删除第一个值为x的元素.未找到指定元素时,触发ValueError异常.\n\nlist.pop([i])\n移除列表中给定位置上的条目,并返回该条目.如果未指定索引号,则a.pop()将移除并返回列表中的最后一个条目.如果列表为空或索引号在列表索引范围之外则会引发IndexError.\n\nlist.clear()\n移除列表中的所有项.类似于del a[:]\n\nlist.index(x[,start[,end]])\n返回列表中第一个值为x的元素的零基索引.未找到指定元素时,触发,ValueError异常.\n可选参数start和end是切片符号,用于将搜索限制为列表的特定子序列.\n\nlist.count(x)\n返回列表中元素x出现的次数.\n\nlist.sort(*,key&#x3D;None,reverse&#x3D;False)\n就地排序列表中的元素(详见sorted())\n\nlist.reverse()\n翻转列表中的元素.\n\nlist.copy()\n返回列表的浅拷贝.类似于a[:].\n\n\n2.1.2 用列表实现堆栈堆栈就是”后进后出”的线性表.添加条目到栈顶,可使用append(),从栈顶取出条目,则使用pop().\n2.1.3  用列表实现队列队列就是”先进先出”的线性表.\n但是列表作为队列的效率很慢,因为在列表插入或移除元素很慢,所有元素都必须移动一位.\n实现队列最好用collections.deque,可以快速从两端添加或删除元素.\ncollections.deque模块的常用方法\n\nappendleft(x)\n在队列左端添加元素.\n\npopleft(x)\n在队列左端删除元素.\n\nextendleft(iterable)\n在队列左端添加可迭代对象的所有项.\n\n\n实例:\nfrom collections import dequequeue=deque([&quot;Eric&quot;,&quot;john&quot;,&quot;Michael&quot;])queue.append(&quot;Terry&quot;)queue.append(&quot;Graham&quot;)queue.popleft()queue.popleft()\n\n2.1.4 列表推导式列表推导式的语法:\n[expression for statement (for statement)* (if statement)*]\n即一个表达式,后面为一个for子句,然后,是零个或多个for或if子句.\n2.1.5 del语句可以按索引从一个列表移除条目.\n2.2 元祖2.2.1 单元素元祖必须在元素后面接逗号.如(&#39;a&#39;,),&#39;hello&#39;,\n2.2.2 打包和解包t&#x3D;12345,54321,’hello’\n这是打包\nx,y,z&#x3D;t\n这是解包\n2.3 集合2.3.1 集合的创建创建集合用花括号或set()函数,创建空集合只能用set(),以免和字典冲突.\n2.3.2 集合运算符\n\n\n\n作用:差集\n\n|\n作用:并集\n\n&amp;\n作用:交集\n\n^\n作用:存在于a或b中但非两者中皆有的元素.\n\n\n2.4 字典2.4.1 字典推导式语法:\nexpression for statement (for statement)* (if statement)*\n2.5 深入条件控制\n比较运算符:in not is is not &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D;\n布尔运算符:not and or\n\n比较运算符的优先级大于布尔运算符,比较运算符的优先级一样,布尔运算符的优先级not &gt; and &gt;or.\n3 模块3.1 模块详解3.1.1 以脚本模式运行Python模块语法:\npython fibo.py &lt;arguments&gt;\n参数:\narguments:命令行参数,在运行脚本时传递给Python程序使用.在Python脚本中,命令行参数一般通过sys.argv访问.sys.argv[0]代表脚本名,sys.argv[1]代表第一个命令行参数,以此类推.\n3.1.2 模块搜索路径当导入一个模块时,搜索优先级为:\n\n内置模块,在sys.builtin_module_names中列出\nsys.path所给出的目录列表\n\nsys.path包含以下位置:\n\n被命令行直接运行的脚本所在的目录(或指定的当前目录)\nPYTHONPATH(目录列表,与shell变量PATH的语法一样)\n依赖于安装的默认值(按照惯例包括一个site-packages目录,有site模块处理)\n\n3.1.3 “已编译的”Python文件__pycache__是Python模块的编译版本目录目录,在这个目录中,文件名为module.version.pyc,module是模块名,version是Python版本号(但与一般的版本号有区别),pyc是固定后缀,例如:在CPython3.3发行版中,spam.py模块的编译版本缓存为__pycache__/spam.cpython-33.pyc.\n3.2 标准模块Python自带一个标准模块的库.\n特别的模块sys,内嵌的标准模块,sys.ps1,sys.ps2定义了一些子付,用作主提示符和辅助提示符.sys.path是字符串列表,用于确定解释器的模块搜索路径.该路径以环境变量PYTHONPATH提取的默认路径进行初始化,如未设置PYTHONPATH,则使用内置的默认路径.\n甚至可以使用列表操作修改该列表:\nsys.path.append(path)\n3.3 dir()函数内置函数dir()用于查找模块定义的名称.返回结果是经过排序的字符串列表.\n语法:\ndir(module)\n作用:返回模块定义的名称.没有参数时,返回当前已定义的名称.\n定义的名称包括:变量,模块,函数,…\ndir()不会列出内置函数及其变量的名称,这些内容的定义在标准模块builtins中.\n3.4 包包是通过使用”带点号模块名”来构造Python模块命名空间的一种方式.\n一般地,需要有__init__.py文件才能让Python将包含该文件的目录当作包来处理(除非使用namespace package).在最简单的情况下,__init__可以只是一个空文件,但它也可以执行包的初始化代码或设置__all__变量.\n3.5 从包中导入*不建议使用from package import *时,因为会花费很长的时间,除非作者在__init__.py代码中定义了列表__all__.如果存在__all__列表,运行from package import *时,它就是被导入的模块名列表.发布包的新版本时,包的作者应更新此列表.\n4 变量和标识符4.1 变量Python中的变量使用标识符标识,无需声明类型即可创建\n4.2 标识符Python中的标识符遵循以下规则:\n\n使用字母,数字和下划线”_”组成\n数字不能再标识符的开头\n区分大小写\n\n5 输入与输出5.1 更复杂的输出格式格式化输出的方法:\n\n格式化字符串字面值,俗称f-格式化.要在字符串开头的引号&#x2F;三引号前添加f或F.\n字符串的str.format()方法\n\n5.1.1 格式化字符串字面值语法:\n{expression}\n其中,格式说明符是可选的.\n常用的格式说明符:\n\n.nf:表示精确到n为小数\n冒号接的整数,表示设置最小字符宽度.\n在冒号之前,一些修饰符可以在格式化前转换值,’!a’应用ascii(),’!s’应用str(),’!r’应用repr().\n&#x3D;说明符(在冒号之前)用于显示变量,即”变量&#x3D;值”.\n\n5.1.2 字符串format()方法str.fromat()方法的基本用法:\n&quot;&#123;expression&#125;&quot;.format(args)\n\n无参数\n花括号中没有任何参数,实际上隐藏了位置参数.\n\n位置参数\n花括号中的数字表示传递给str.format()方法的对象所在的位置.\n\n关键字参数\n花括号中的参数与str.format()方法中的关键字参数对应,类似于函数中的关键字参数.\n\n\n5.1.3 手动格式化字符串\nstr.rjust(num)\n作用:在左侧填充空格,num是给定宽度.\n\nstr.ljust(num)\n作用:在右侧填充空格,num是给定宽度.\n\nstr.center(num)\n作用:在两侧填充空格,num是给定宽度.\n\nstr.zfill()\n作用:在数字字符串左边填充零,且能识别正负号.\n\n\n5.2 读写文件5.2.1 文件对象的方法\nf.read(size)\n作用:读取文件内容.\n参数:\n\nsize:读取最多size个字符(文本模式)或size个字节(二进制模式).\n\n\nf.readline()\n作用:从文件中读取单行数据.字符串末尾保留换行符.\n\nfor line in f:\n作用:遍历整个文件对象,即从文件中读取多行.\n\nlist(f)\n作用:将文件对象转换成列表,内容与f.readlines()相同.\n\nf.readlines()\n作用:读取文件中的所有行.\n\nf.write(string)\n作用:把string的内容写入文件,并返回写入的字符数.\n\nf.tell()\n作用:返回整数,给出文件对象在文件中的对钱位置,表示为二进制模式下时从文件开始的字节数和文本模式下的意义不明的数字.\n\nf.seek(offset,whence)\n作用:可以改变文件对象的位置.\n参数:\n\noffset:偏移量.\nwhence:指定参考点,0表示开头,1你是当前文件位置,2表示文件默认,默认0.\n\n注意:\n\n在文本模式中,只允许从文件开头搜索.\n有效的offset值必须属于f.tell()的返回值或0.\n\n\n\n5.2.2 使用json保存结构化数据Python允许使用流行的数据交换格式JSON(JavaScript Object Notation).标准库模块json可以接受带有层级结构的Python数据,并将其转换为字符串表示形式,这个过程称为序列化(serializing,根据字符串表示形式重建数据则称为反序列化(deserializing).\n\njson.dumps(obj)\n作用:将对象转换成JSON字符串表示形式,即序列化.\n\njson.dump(obj,file)\n作用:将对象序列化为文本文件.\n参数:\n\nobj:给定对象.\nfile:文本文件对象.\n\n\njson.load(file)\n作用:将打开的二进制,文本文件反序列化为Python对象.\n\n\n6 类6.1 名称和对象Python类也是对象,对象之间相互对立.\n多个名称可以绑定到同一对象,被称为”别名”.\n6.2 Python作用域和命名空间命名空间(namespace)是从名称到对象的映射.\n点号之后的名称是属性.\n属性可以是只读的或者可写的.\n一个命名空间的作用域是Python代码中的一段文本区域,从这个区域可直接访问该命名空间.\n“可直接访问”的意思是,该文本区域而名称在被限定引用时,查找名称的范围,\n6.2.1 global和nonlocal这两个关键字都是改变名称的作用域:\n\nglobal:声明特定变量在全局作用域力,在全局作用域中重新绑定.\nnonlocal:声明特定变量在外层作用域中,在外层作用域中重新绑定.\n\n6.3 初探类类引入了一个新语法,三种新的对象类型和一些新语义.\n6.3.1 类定义语法语法:\nclass ClassName:    &lt;语句-1&gt;    .    .    .    &lt;语句-N&gt;\n\n6.3.2 Class对象每个值都是一个对像,因此具有类,类的名称存储在object.__class__.\n类对象支持两种操作:属性引用和实例化.\n当一个类定义了__init__()方法时,类的实例化会自动为新创建的类实例发起调用__init__().并且在类实例化的过程中的参数,传递给了类中的__init__()方法.\n6.3.3 实例对象实例对象的唯一操作是属性引用.有两种有效的属性名称:数据属性和方法.\n6.3.4 方法对象方法的特殊之处:\n实例对象会作为函数的第一个参数被传入.\n6.3.5 类和实例变量一般地,实例变量使用每个实例的唯一数据,而类变量用于类的所有实例共享的属性和方法.\n6.4 继承语法:\nclass DerivedClassName(BaseClassName)\n注意点:\n派生类的属性引用会先从派生类中查找,再从基类中查找,如果基类也有基类,再从基类的基类中查找,直到递归地找到属性引用.\n两个内置函数用于类的继承:\n\nisinstance(obj,class)\n作用:检查一个实例的类型.仅会在obj.__class__为int或obj的类派生自int的类时为True.\n\nissubclass(base,parent)\n作用:检查base是否继承与parent,或base是否是parent的子类.\n\n\n6.4.1 多重继承Python也支持一种多重继承,语法:\nclass DerivedClassName(Base1,Base2,Base3):\n属性引用会现在DerivedClassName中查找,就会在Base1中搜索它,然后递归地在Base1的基类中搜索,如果在那里也找不到,在Base2中搜索,依次类推.\n6.5 私有变量为何形式为__name的标识符(至少带有两个前缀下划线,至多一个后缀下划线)的文本将被替换为_classname__name,其中classname为去除了前缀下划线的当前名称.\n6.6 迭代器用for语句阐述迭代器:\nfor语句会在容器对象上调用iter()(或者是__iter__()方法).该函数返回一个定义了__next__()方法的迭代器对象,此方法将逐一访问容器中的元素.当元素用尽时,__next__()将引发StopIteration异常来通知终止for循环.\n可以使用next()内置函数来调用__next__()方法.\n实例:\nclass Reverse:    def __init__(self,data):        self.data=data        self.index=len(data)    def __iter__(self):        return self        def __next__(self):        if self.index==0:            raise StopIteration        self.index=self.index-1        return self.data[self.index]    rev=Reverse(&#x27;spam&#x27;)for char in rev:    print(char)&#x27;&#x27;&#x27;输出maps&#x27;&#x27;&#x27;\n\n6.7 生成器生成器是一个用于创建迭代器的简单而强大的工具.\n生成器会自动创建__iter__()和__next__方法.\n实例:\ndef reverse(data):    for index in range(len(data)-1,-1,-1):        yield data[index]    for char in reverse(&#x27;golf&#x27;):    print(char)&#x27;&#x27;&#x27;输出flog&#x27;&#x27;&#x27;\n\n6.8 生成器表达式与列表表达式类似,但外层是圆括号()而非方括号[].\n实例:\nsum(i*i for i in range(10))\n\n7 虚拟环境和包8 基础标准库附录A Python 关键字使用print(keyword.kwlist) #import keyword查看Python当前的所有关键字.\nPython所有关键字Python的3.13版本的关键字有36个:\n[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]\n\nPython关键字的分类\n\n值\nNone True False\n\n异步\nawait async\n\n操作符\nis in not and or\n\n函数\ndef lambda return\n\n作用域\nglobal nonlocal\n\n条件\nif elif else\n\n异常\ntry except *else finally assert raise continue from\n\n模块\nimport as from\n\n上下文管理器\nwith *as\n\n循环\nfor *in while continue break *else\n\n类\nclass\n\n方法\ndel\n\n生成器\nyield\n\n占位\npass\n\n匹配\nmatch case *as\n\n\n其中,*key表示重复的关键字,关键字最多的分类是异常分类,有六个关键字,大部分分类只有1~3个关键字.\n","categories":["Python"],"tags":["技术"]}]